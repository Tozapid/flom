Road map:

go on with Valgrind sanification, restart from "TLS wrong client id, no server check"
test on all the distributions...
TLS in client API

Memory leak sanification: start a daemon, stop with -X and a possibly lost appears:
==23395== 272 bytes in 1 blocks are possibly lost in loss record 693 of 777
==23395==    at 0x4C267CC: calloc (vg_replace_malloc.c:467)
==23395==    by 0x4012495: _dl_allocate_tls (dl-tls.c:300)
==23395==    by 0x5556728: pthread_create@@GLIBC_2.2.5 (allocatestack.c:561)
==23395==    by 0x4E2F35D: ??? (in /usr/lib/libgthread-2.0.so.0.2400.1)
==23395==    by 0x5099A8D: g_thread_create_full (in /lib/libglib-2.0.so.0.2400.1)
==23395==    by 0x5D17D2D: flom_accept_loop_start_locker (flom_daemon.c:1810)
==23395==    by 0x5D19BB4: flom_accept_loop_transfer (flom_daemon.c:1611)
==23395==    by 0x5D1A49F: flom_accept_loop_pollin (flom_daemon.c:1328)
==23395==    by 0x5D1A8AF: flom_accept_loop (flom_daemon.c:1047)
==23395==    by 0x5D1AFDF: flom_daemon (flom_daemon.c:238)
==23395==    by 0x5D10E46: flom_client_connect_tcp (flom_client.c:344)
==23395==    by 0x5D12123: flom_client_connect (flom_client.c:98)
Start a daemon, access again the same resource, stop with -X and the possibly lost disappears...

remove config property resource_wait; remove from man page too; update wiki site using --resource-timeout instead of --wait

implement a loop for connect/bind if bind returns an error: this shuold help
to reduce the race condition between a closing daemon and a starting client.
See this thread: https://github.com/tiian/flom/issues/3

transactional sequences (no holes sequences): use a regex like expression
to describe the sequence; for example:
[0-9](2)[A-Z](3)
produces: 00AAA 00AAB 00AAC ... 01AAA 01AAB ... 01ABA 01ABB 01ABC ...

unique timestamps (no two equal timestamps supplied): use a date like expression
to describe the sequence; for example:
%I%M%S
produces: 213105 213106 213209 ... but not: 213105 213105 even if two clients
ask for a unique timestamp during the same second (the second client will wait)

"object" resources with a state, a memory area, managed by FLoM to transform it in a "state manager" other than a "lock manager"; for flom client, the object will be dumped/restored to/from file

"vector" resources with an associative array of memory areas, managed by FLoM (evolution of "object"; for flom client, the vector will be dumped/restored to/from a zip file or a directory

RESTful interface implemented using Mongoose (?)

replace poll custom based implementation with libevent... (is it interesting?)

put inside function flom_accept_loop_chklockers a check if the thread associated to the locker is really active; if the thread leaved (due to an error), make a clean-up phase. This avoid a daemon crash after a thread terminated with an error, but listener thread has a "locker object" already active

implement FIFO, LIFO, FIRST FIT (for numerical resources) lock allocation policies
